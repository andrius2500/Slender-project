{"ast":null,"code":"import _classCallCheck from \"C:/Users/Andrius/Desktop/Slender-project/slender-main/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Andrius/Desktop/Slender-project/slender-main/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar Queue = /*#__PURE__*/function () {\n  function Queue() {\n    _classCallCheck(this, Queue);\n    this.order = [];\n    this.scheduled = new Set();\n  }\n  _createClass(Queue, [{\n    key: \"add\",\n    value: function add(process) {\n      if (!this.scheduled.has(process)) {\n        this.scheduled.add(process);\n        this.order.push(process);\n        return true;\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(process) {\n      var index = this.order.indexOf(process);\n      if (index !== -1) {\n        this.order.splice(index, 1);\n        this.scheduled.delete(process);\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.order.length = 0;\n      this.scheduled.clear();\n    }\n  }]);\n  return Queue;\n}();\nfunction createRenderStep(runNextFrame) {\n  /**\n   * We create and reuse two queues, one to queue jobs for the current frame\n   * and one for the next. We reuse to avoid triggering GC after x frames.\n   */\n  var thisFrame = new Queue();\n  var nextFrame = new Queue();\n  var numToRun = 0;\n  /**\n   * Track whether we're currently processing jobs in this step. This way\n   * we can decide whether to schedule new jobs for this frame or next.\n   */\n  var isProcessing = false;\n  var flushNextFrame = false;\n  /**\n   * A set of processes which were marked keepAlive when scheduled.\n   */\n  var toKeepAlive = new WeakSet();\n  var step = {\n    /**\n     * Schedule a process to run on the next frame.\n     */\n    schedule: function schedule(callback) {\n      var keepAlive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var addToCurrentFrame = immediate && isProcessing;\n      var queue = addToCurrentFrame ? thisFrame : nextFrame;\n      if (keepAlive) toKeepAlive.add(callback);\n      if (queue.add(callback) && addToCurrentFrame && isProcessing) {\n        // If we're adding it to the currently running queue, update its measured size\n        numToRun = thisFrame.order.length;\n      }\n      return callback;\n    },\n    /**\n     * Cancel the provided callback from running on the next frame.\n     */\n    cancel: function cancel(callback) {\n      nextFrame.remove(callback);\n      toKeepAlive.delete(callback);\n    },\n    /**\n     * Execute all schedule callbacks.\n     */\n    process: function process(frameData) {\n      /**\n       * If we're already processing we've probably been triggered by a flushSync\n       * inside an existing process. Instead of executing, mark flushNextFrame\n       * as true and ensure we flush the following frame at the end of this one.\n       */\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n      isProcessing = true;\n      var _ref = [nextFrame, thisFrame];\n      thisFrame = _ref[0];\n      nextFrame = _ref[1];\n      // Clear the next frame queue\n      nextFrame.clear();\n      // Execute this frame\n      numToRun = thisFrame.order.length;\n      if (numToRun) {\n        for (var i = 0; i < numToRun; i++) {\n          var callback = thisFrame.order[i];\n          callback(frameData);\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n          }\n        }\n      }\n      isProcessing = false;\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\nexport { createRenderStep };","map":{"version":3,"names":["Queue","order","scheduled","Set","process","has","add","push","index","indexOf","splice","delete","length","clear","createRenderStep","runNextFrame","thisFrame","nextFrame","numToRun","isProcessing","flushNextFrame","toKeepAlive","WeakSet","step","schedule","callback","keepAlive","immediate","addToCurrentFrame","queue","cancel","remove","frameData","i"],"sources":["C:/Users/Andrius/Desktop/Slender-project/slender-main/node_modules/framer-motion/dist/es/frameloop/render-step.mjs"],"sourcesContent":["class Queue {\n    constructor() {\n        this.order = [];\n        this.scheduled = new Set();\n    }\n    add(process) {\n        if (!this.scheduled.has(process)) {\n            this.scheduled.add(process);\n            this.order.push(process);\n            return true;\n        }\n    }\n    remove(process) {\n        const index = this.order.indexOf(process);\n        if (index !== -1) {\n            this.order.splice(index, 1);\n            this.scheduled.delete(process);\n        }\n    }\n    clear() {\n        this.order.length = 0;\n        this.scheduled.clear();\n    }\n}\nfunction createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Queue();\n    let nextFrame = new Queue();\n    let numToRun = 0;\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (queue.add(callback) && addToCurrentFrame && isProcessing) {\n                // If we're adding it to the currently running queue, update its measured size\n                numToRun = thisFrame.order.length;\n            }\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.remove(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Clear the next frame queue\n            nextFrame.clear();\n            // Execute this frame\n            numToRun = thisFrame.order.length;\n            if (numToRun) {\n                for (let i = 0; i < numToRun; i++) {\n                    const callback = thisFrame.order[i];\n                    callback(frameData);\n                    if (toKeepAlive.has(callback)) {\n                        step.schedule(callback);\n                        runNextFrame();\n                    }\n                }\n            }\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}